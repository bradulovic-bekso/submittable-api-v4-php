<?php
/**
 * FormsApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Submittable API Documentation
 *
 * This page contains the documentation on how to use Submittable through API calls.  ### Breaking changes   * All v3/requests and v3/responses endpoints merged into v4/entries endpoints     * Entries are a combination of both the request and response from v3 * All endpoints returning a page now use a continuation token instead of page number and page size     * Endpoints no longer return a count of how many items there are     * Endpoints no longer return how many pages there are     * Filters and size are made on the first request only, subsequent requests can only use the continuation token returned on the response. * Get a submission now returns formEntries instead of formResponses     * formEntries does not contain the fieldData property         * To get a single entry use the \"Get an entry\" endpoint, /v4/entries/{entryId}         * To get all entries for a submission use the \"Get a submissionâ€™s entries\" endpoint, /v4/entries/submissions/{submissionId} * All submissionId properties are now guids instead of integers * All labelId properties are now guids instead of integers * LegacyProjects.Include and LegacyProjects.Exclude on /v3/submissions have been removed * Update project endpoint /v3/projects/{projectId} now updates everything for a project * v3/projects/stages endpoints are removed, now review stages are managed by the create and update project endpoints * Get a list of team members and their assignment counts /v3/organizations/team/assignments has been replaced by /v4/organizations/team to get team members and /v4/submissions/team/assignment to get their assignment counts   ### Authentication  To access the API, you must present an API Key provisioned for your organization.  The API Key is sent using a basic authentication header, with the API key as the username and a blank password. Please ensure that the value is formatted as `{apiKey}`.  ``` Authorization: Basic {apiKey} ```  ### Request Content Type  All endpoints, unless otherwise noted, accept and produce `application/json`. Please ensure the `Content-Type` header for POST and PUT requests are set correctly.
 *
 * The version of the OpenAPI document: v4
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.11.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * FormsApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FormsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'v4EntriesAdditionalPost' => [
            'application/json',
        ],
        'v4EntriesAdditionalRescindPost' => [
            'application/json',
        ],
        'v4EntriesEditingClosePost' => [
            'application/json',
        ],
        'v4EntriesEditingOpenPost' => [
            'application/json',
        ],
        'v4EntriesEntryIdClosePost' => [
            'application/json',
        ],
        'v4EntriesEntryIdDelete' => [
            'application/json',
        ],
        'v4EntriesEntryIdFieldsFieldIdPost' => [
            'application/json',
        ],
        'v4EntriesEntryIdFilesFileIdGet' => [
            'application/json',
        ],
        'v4EntriesEntryIdGet' => [
            'application/json',
        ],
        'v4EntriesEntryIdOpenPost' => [
            'application/json',
        ],
        'v4EntriesEntryIdPatch' => [
            'application/json',
        ],
        'v4EntriesEntryIdPut' => [
            'application/json',
        ],
        'v4EntriesEntryIdTablesTableIdGet' => [
            'application/json',
        ],
        'v4EntriesFormsFormIdGet' => [
            'application/json',
        ],
        'v4EntriesInternalPost' => [
            'application/json',
        ],
        'v4EntriesMessagePost' => [
            'application/json',
        ],
        'v4EntriesMetadataFormsFormIdGet' => [
            'application/json',
        ],
        'v4EntriesRequestFilterEditingClosePut' => [
            'application/json',
        ],
        'v4EntriesRequestFilterEditingOpenPut' => [
            'application/json',
        ],
        'v4EntriesRequestStatusPut' => [
            'application/json',
        ],
        'v4EntriesReviewsEntryIdDelete' => [
            'application/json',
        ],
        'v4EntriesReviewsScorePut' => [
            'application/json',
        ],
        'v4EntriesSubmissionsSubmissionIdGet' => [
            'application/json',
        ],
        'v4EntriesSubmissionsSubmissionIdReviewsGet' => [
            'application/json',
        ],
        'v4FormsFormIdDelete' => [
            'application/json',
        ],
        'v4FormsFormIdGet' => [
            'application/json',
        ],
        'v4FormsFormIdPut' => [
            'application/json',
        ],
        'v4FormsGet' => [
            'application/json',
        ],
        'v4FormsMetadataGet' => [
            'application/json',
        ],
        'v4FormsPost' => [
            'application/json',
        ],
        'v4FormsScheduledScheduledAdditionalFormIdDelete' => [
            'application/json',
        ],
        'v4FormsSubmissionIdScheduledGet' => [
            'application/json',
        ],
        'v4FormsTemplatesPaymentGet' => [
            'application/json',
        ],
        'v4ReviewsReviewResponseIdDelete' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation v4EntriesAdditionalPost
     *
     * Create and send an additional form entry
     *
     * @param  \OpenAPI\Client\Model\CreateAdditionalFormEntryRequest|null $create_additional_form_entry_request create_additional_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\AdditionalFormEntryResponse|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4EntriesAdditionalPost($create_additional_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalPost'][0])
    {
        list($response) = $this->v4EntriesAdditionalPostWithHttpInfo($create_additional_form_entry_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesAdditionalPostWithHttpInfo
     *
     * Create and send an additional form entry
     *
     * @param  \OpenAPI\Client\Model\CreateAdditionalFormEntryRequest|null $create_additional_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\AdditionalFormEntryResponse|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesAdditionalPostWithHttpInfo($create_additional_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalPost'][0])
    {
        $request = $this->v4EntriesAdditionalPostRequest($create_additional_form_entry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\AdditionalFormEntryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\AdditionalFormEntryResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\AdditionalFormEntryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\AdditionalFormEntryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\AdditionalFormEntryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesAdditionalPostAsync
     *
     * Create and send an additional form entry
     *
     * @param  \OpenAPI\Client\Model\CreateAdditionalFormEntryRequest|null $create_additional_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesAdditionalPostAsync($create_additional_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalPost'][0])
    {
        return $this->v4EntriesAdditionalPostAsyncWithHttpInfo($create_additional_form_entry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesAdditionalPostAsyncWithHttpInfo
     *
     * Create and send an additional form entry
     *
     * @param  \OpenAPI\Client\Model\CreateAdditionalFormEntryRequest|null $create_additional_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesAdditionalPostAsyncWithHttpInfo($create_additional_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\AdditionalFormEntryResponse';
        $request = $this->v4EntriesAdditionalPostRequest($create_additional_form_entry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesAdditionalPost'
     *
     * @param  \OpenAPI\Client\Model\CreateAdditionalFormEntryRequest|null $create_additional_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesAdditionalPostRequest($create_additional_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalPost'][0])
    {



        $resourcePath = '/v4/entries/additional';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_additional_form_entry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_additional_form_entry_request));
            } else {
                $httpBody = $create_additional_form_entry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesAdditionalRescindPost
     *
     * Rescind additional form requests
     *
     * @param  \OpenAPI\Client\Model\RescindAdditionalFormsRequest|null $rescind_additional_forms_request rescind_additional_forms_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalRescindPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|string[]
     */
    public function v4EntriesAdditionalRescindPost($rescind_additional_forms_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalRescindPost'][0])
    {
        list($response) = $this->v4EntriesAdditionalRescindPostWithHttpInfo($rescind_additional_forms_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesAdditionalRescindPostWithHttpInfo
     *
     * Rescind additional form requests
     *
     * @param  \OpenAPI\Client\Model\RescindAdditionalFormsRequest|null $rescind_additional_forms_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalRescindPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesAdditionalRescindPostWithHttpInfo($rescind_additional_forms_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalRescindPost'][0])
    {
        $request = $this->v4EntriesAdditionalRescindPostRequest($rescind_additional_forms_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 204:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesAdditionalRescindPostAsync
     *
     * Rescind additional form requests
     *
     * @param  \OpenAPI\Client\Model\RescindAdditionalFormsRequest|null $rescind_additional_forms_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalRescindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesAdditionalRescindPostAsync($rescind_additional_forms_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalRescindPost'][0])
    {
        return $this->v4EntriesAdditionalRescindPostAsyncWithHttpInfo($rescind_additional_forms_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesAdditionalRescindPostAsyncWithHttpInfo
     *
     * Rescind additional form requests
     *
     * @param  \OpenAPI\Client\Model\RescindAdditionalFormsRequest|null $rescind_additional_forms_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalRescindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesAdditionalRescindPostAsyncWithHttpInfo($rescind_additional_forms_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalRescindPost'][0])
    {
        $returnType = 'string[]';
        $request = $this->v4EntriesAdditionalRescindPostRequest($rescind_additional_forms_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesAdditionalRescindPost'
     *
     * @param  \OpenAPI\Client\Model\RescindAdditionalFormsRequest|null $rescind_additional_forms_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesAdditionalRescindPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesAdditionalRescindPostRequest($rescind_additional_forms_request = null, string $contentType = self::contentTypes['v4EntriesAdditionalRescindPost'][0])
    {



        $resourcePath = '/v4/entries/additional/rescind';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($rescind_additional_forms_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($rescind_additional_forms_request));
            } else {
                $httpBody = $rescind_additional_forms_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEditingClosePost
     *
     * Close entries for editing
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingClosePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|string[]
     */
    public function v4EntriesEditingClosePost($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingClosePost'][0])
    {
        list($response) = $this->v4EntriesEditingClosePostWithHttpInfo($update_entries_is_open_for_editing_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEditingClosePostWithHttpInfo
     *
     * Close entries for editing
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingClosePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEditingClosePostWithHttpInfo($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingClosePost'][0])
    {
        $request = $this->v4EntriesEditingClosePostRequest($update_entries_is_open_for_editing_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEditingClosePostAsync
     *
     * Close entries for editing
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingClosePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEditingClosePostAsync($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingClosePost'][0])
    {
        return $this->v4EntriesEditingClosePostAsyncWithHttpInfo($update_entries_is_open_for_editing_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEditingClosePostAsyncWithHttpInfo
     *
     * Close entries for editing
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingClosePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEditingClosePostAsyncWithHttpInfo($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingClosePost'][0])
    {
        $returnType = 'string[]';
        $request = $this->v4EntriesEditingClosePostRequest($update_entries_is_open_for_editing_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEditingClosePost'
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingClosePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEditingClosePostRequest($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingClosePost'][0])
    {



        $resourcePath = '/v4/entries/editing/close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_entries_is_open_for_editing_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_entries_is_open_for_editing_request));
            } else {
                $httpBody = $update_entries_is_open_for_editing_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEditingOpenPost
     *
     * Open entries for editing
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingOpenPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|string[]
     */
    public function v4EntriesEditingOpenPost($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingOpenPost'][0])
    {
        list($response) = $this->v4EntriesEditingOpenPostWithHttpInfo($update_entries_is_open_for_editing_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEditingOpenPostWithHttpInfo
     *
     * Open entries for editing
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingOpenPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEditingOpenPostWithHttpInfo($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingOpenPost'][0])
    {
        $request = $this->v4EntriesEditingOpenPostRequest($update_entries_is_open_for_editing_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEditingOpenPostAsync
     *
     * Open entries for editing
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingOpenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEditingOpenPostAsync($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingOpenPost'][0])
    {
        return $this->v4EntriesEditingOpenPostAsyncWithHttpInfo($update_entries_is_open_for_editing_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEditingOpenPostAsyncWithHttpInfo
     *
     * Open entries for editing
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingOpenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEditingOpenPostAsyncWithHttpInfo($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingOpenPost'][0])
    {
        $returnType = 'string[]';
        $request = $this->v4EntriesEditingOpenPostRequest($update_entries_is_open_for_editing_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEditingOpenPost'
     *
     * @param  \OpenAPI\Client\Model\UpdateEntriesIsOpenForEditingRequest|null $update_entries_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEditingOpenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEditingOpenPostRequest($update_entries_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEditingOpenPost'][0])
    {



        $resourcePath = '/v4/entries/editing/open';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_entries_is_open_for_editing_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_entries_is_open_for_editing_request));
            } else {
                $httpBody = $update_entries_is_open_for_editing_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdClosePost
     *
     * Close editing
     *
     * @param  string $entry_id entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdClosePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|string[]
     */
    public function v4EntriesEntryIdClosePost($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdClosePost'][0])
    {
        list($response) = $this->v4EntriesEntryIdClosePostWithHttpInfo($entry_id, $update_is_open_for_editing_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEntryIdClosePostWithHttpInfo
     *
     * Close editing
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdClosePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdClosePostWithHttpInfo($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdClosePost'][0])
    {
        $request = $this->v4EntriesEntryIdClosePostRequest($entry_id, $update_is_open_for_editing_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdClosePostAsync
     *
     * Close editing
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdClosePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdClosePostAsync($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdClosePost'][0])
    {
        return $this->v4EntriesEntryIdClosePostAsyncWithHttpInfo($entry_id, $update_is_open_for_editing_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdClosePostAsyncWithHttpInfo
     *
     * Close editing
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdClosePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdClosePostAsyncWithHttpInfo($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdClosePost'][0])
    {
        $returnType = 'string[]';
        $request = $this->v4EntriesEntryIdClosePostRequest($entry_id, $update_is_open_for_editing_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdClosePost'
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdClosePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdClosePostRequest($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdClosePost'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdClosePost'
            );
        }



        $resourcePath = '/v4/entries/{entryId}/close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_is_open_for_editing_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_is_open_for_editing_request));
            } else {
                $httpBody = $update_is_open_for_editing_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdDelete
     *
     * Delete an entry
     *
     * @param  string $entry_id entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4EntriesEntryIdDelete($entry_id, string $contentType = self::contentTypes['v4EntriesEntryIdDelete'][0])
    {
        $this->v4EntriesEntryIdDeleteWithHttpInfo($entry_id, $contentType);
    }

    /**
     * Operation v4EntriesEntryIdDeleteWithHttpInfo
     *
     * Delete an entry
     *
     * @param  string $entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdDeleteWithHttpInfo($entry_id, string $contentType = self::contentTypes['v4EntriesEntryIdDelete'][0])
    {
        $request = $this->v4EntriesEntryIdDeleteRequest($entry_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdDeleteAsync
     *
     * Delete an entry
     *
     * @param  string $entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdDeleteAsync($entry_id, string $contentType = self::contentTypes['v4EntriesEntryIdDelete'][0])
    {
        return $this->v4EntriesEntryIdDeleteAsyncWithHttpInfo($entry_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdDeleteAsyncWithHttpInfo
     *
     * Delete an entry
     *
     * @param  string $entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdDeleteAsyncWithHttpInfo($entry_id, string $contentType = self::contentTypes['v4EntriesEntryIdDelete'][0])
    {
        $returnType = '';
        $request = $this->v4EntriesEntryIdDeleteRequest($entry_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdDelete'
     *
     * @param  string $entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdDeleteRequest($entry_id, string $contentType = self::contentTypes['v4EntriesEntryIdDelete'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdDelete'
            );
        }


        $resourcePath = '/v4/entries/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdFieldsFieldIdPost
     *
     * Get a file upload url
     *
     * @param  string $entry_id entry_id (required)
     * @param  string $field_id field_id (required)
     * @param  \OpenAPI\Client\Model\CreateResponseFileRequest|null $create_response_file_request create_response_file_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CreateFileResult|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4EntriesEntryIdFieldsFieldIdPost($entry_id, $field_id, $create_response_file_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'][0])
    {
        list($response) = $this->v4EntriesEntryIdFieldsFieldIdPostWithHttpInfo($entry_id, $field_id, $create_response_file_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEntryIdFieldsFieldIdPostWithHttpInfo
     *
     * Get a file upload url
     *
     * @param  string $entry_id (required)
     * @param  string $field_id (required)
     * @param  \OpenAPI\Client\Model\CreateResponseFileRequest|null $create_response_file_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CreateFileResult|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdFieldsFieldIdPostWithHttpInfo($entry_id, $field_id, $create_response_file_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'][0])
    {
        $request = $this->v4EntriesEntryIdFieldsFieldIdPostRequest($entry_id, $field_id, $create_response_file_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CreateFileResult' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CreateFileResult' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CreateFileResult', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\CreateFileResult';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CreateFileResult',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdFieldsFieldIdPostAsync
     *
     * Get a file upload url
     *
     * @param  string $entry_id (required)
     * @param  string $field_id (required)
     * @param  \OpenAPI\Client\Model\CreateResponseFileRequest|null $create_response_file_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdFieldsFieldIdPostAsync($entry_id, $field_id, $create_response_file_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'][0])
    {
        return $this->v4EntriesEntryIdFieldsFieldIdPostAsyncWithHttpInfo($entry_id, $field_id, $create_response_file_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdFieldsFieldIdPostAsyncWithHttpInfo
     *
     * Get a file upload url
     *
     * @param  string $entry_id (required)
     * @param  string $field_id (required)
     * @param  \OpenAPI\Client\Model\CreateResponseFileRequest|null $create_response_file_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdFieldsFieldIdPostAsyncWithHttpInfo($entry_id, $field_id, $create_response_file_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CreateFileResult';
        $request = $this->v4EntriesEntryIdFieldsFieldIdPostRequest($entry_id, $field_id, $create_response_file_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdFieldsFieldIdPost'
     *
     * @param  string $entry_id (required)
     * @param  string $field_id (required)
     * @param  \OpenAPI\Client\Model\CreateResponseFileRequest|null $create_response_file_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdFieldsFieldIdPostRequest($entry_id, $field_id, $create_response_file_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdFieldsFieldIdPost'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdFieldsFieldIdPost'
            );
        }

        // verify the required parameter 'field_id' is set
        if ($field_id === null || (is_array($field_id) && count($field_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $field_id when calling v4EntriesEntryIdFieldsFieldIdPost'
            );
        }



        $resourcePath = '/v4/entries/{entryId}/fields/{fieldId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }
        // path params
        if ($field_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldId' . '}',
                ObjectSerializer::toPathValue($field_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_response_file_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_response_file_request));
            } else {
                $httpBody = $create_response_file_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdFilesFileIdGet
     *
     * Get a url to download the uploaded file
     *
     * @param  string $entry_id entry_id (required)
     * @param  string $file_id file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFilesFileIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetUrlResponse|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4EntriesEntryIdFilesFileIdGet($entry_id, $file_id, string $contentType = self::contentTypes['v4EntriesEntryIdFilesFileIdGet'][0])
    {
        list($response) = $this->v4EntriesEntryIdFilesFileIdGetWithHttpInfo($entry_id, $file_id, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEntryIdFilesFileIdGetWithHttpInfo
     *
     * Get a url to download the uploaded file
     *
     * @param  string $entry_id (required)
     * @param  string $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFilesFileIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetUrlResponse|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdFilesFileIdGetWithHttpInfo($entry_id, $file_id, string $contentType = self::contentTypes['v4EntriesEntryIdFilesFileIdGet'][0])
    {
        $request = $this->v4EntriesEntryIdFilesFileIdGetRequest($entry_id, $file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetUrlResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetUrlResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetUrlResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetUrlResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetUrlResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdFilesFileIdGetAsync
     *
     * Get a url to download the uploaded file
     *
     * @param  string $entry_id (required)
     * @param  string $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFilesFileIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdFilesFileIdGetAsync($entry_id, $file_id, string $contentType = self::contentTypes['v4EntriesEntryIdFilesFileIdGet'][0])
    {
        return $this->v4EntriesEntryIdFilesFileIdGetAsyncWithHttpInfo($entry_id, $file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdFilesFileIdGetAsyncWithHttpInfo
     *
     * Get a url to download the uploaded file
     *
     * @param  string $entry_id (required)
     * @param  string $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFilesFileIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdFilesFileIdGetAsyncWithHttpInfo($entry_id, $file_id, string $contentType = self::contentTypes['v4EntriesEntryIdFilesFileIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetUrlResponse';
        $request = $this->v4EntriesEntryIdFilesFileIdGetRequest($entry_id, $file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdFilesFileIdGet'
     *
     * @param  string $entry_id (required)
     * @param  string $file_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdFilesFileIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdFilesFileIdGetRequest($entry_id, $file_id, string $contentType = self::contentTypes['v4EntriesEntryIdFilesFileIdGet'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdFilesFileIdGet'
            );
        }

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling v4EntriesEntryIdFilesFileIdGet'
            );
        }


        $resourcePath = '/v4/entries/{entryId}/files/{fileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }
        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'fileId' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdGet
     *
     * Get an entry
     *
     * @param  string $entry_id entry_id (required)
     * @param  bool|null $prefer_original_version prefer_original_version (optional)
     * @param  bool|null $include_drafts include_drafts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response
     */
    public function v4EntriesEntryIdGet($entry_id, $prefer_original_version = null, $include_drafts = null, string $contentType = self::contentTypes['v4EntriesEntryIdGet'][0])
    {
        list($response) = $this->v4EntriesEntryIdGetWithHttpInfo($entry_id, $prefer_original_version, $include_drafts, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEntryIdGetWithHttpInfo
     *
     * Get an entry
     *
     * @param  string $entry_id (required)
     * @param  bool|null $prefer_original_version (optional)
     * @param  bool|null $include_drafts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdGetWithHttpInfo($entry_id, $prefer_original_version = null, $include_drafts = null, string $contentType = self::contentTypes['v4EntriesEntryIdGet'][0])
    {
        $request = $this->v4EntriesEntryIdGetRequest($entry_id, $prefer_original_version, $include_drafts, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdGetAsync
     *
     * Get an entry
     *
     * @param  string $entry_id (required)
     * @param  bool|null $prefer_original_version (optional)
     * @param  bool|null $include_drafts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdGetAsync($entry_id, $prefer_original_version = null, $include_drafts = null, string $contentType = self::contentTypes['v4EntriesEntryIdGet'][0])
    {
        return $this->v4EntriesEntryIdGetAsyncWithHttpInfo($entry_id, $prefer_original_version, $include_drafts, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdGetAsyncWithHttpInfo
     *
     * Get an entry
     *
     * @param  string $entry_id (required)
     * @param  bool|null $prefer_original_version (optional)
     * @param  bool|null $include_drafts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdGetAsyncWithHttpInfo($entry_id, $prefer_original_version = null, $include_drafts = null, string $contentType = self::contentTypes['v4EntriesEntryIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response';
        $request = $this->v4EntriesEntryIdGetRequest($entry_id, $prefer_original_version, $include_drafts, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdGet'
     *
     * @param  string $entry_id (required)
     * @param  bool|null $prefer_original_version (optional)
     * @param  bool|null $include_drafts (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdGetRequest($entry_id, $prefer_original_version = null, $include_drafts = null, string $contentType = self::contentTypes['v4EntriesEntryIdGet'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdGet'
            );
        }




        $resourcePath = '/v4/entries/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prefer_original_version,
            'preferOriginalVersion', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $include_drafts,
            'includeDrafts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdOpenPost
     *
     * Open editing
     *
     * @param  string $entry_id entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdOpenPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|string[]
     */
    public function v4EntriesEntryIdOpenPost($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdOpenPost'][0])
    {
        list($response) = $this->v4EntriesEntryIdOpenPostWithHttpInfo($entry_id, $update_is_open_for_editing_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEntryIdOpenPostWithHttpInfo
     *
     * Open editing
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdOpenPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdOpenPostWithHttpInfo($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdOpenPost'][0])
    {
        $request = $this->v4EntriesEntryIdOpenPostRequest($entry_id, $update_is_open_for_editing_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdOpenPostAsync
     *
     * Open editing
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdOpenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdOpenPostAsync($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdOpenPost'][0])
    {
        return $this->v4EntriesEntryIdOpenPostAsyncWithHttpInfo($entry_id, $update_is_open_for_editing_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdOpenPostAsyncWithHttpInfo
     *
     * Open editing
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdOpenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdOpenPostAsyncWithHttpInfo($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdOpenPost'][0])
    {
        $returnType = 'string[]';
        $request = $this->v4EntriesEntryIdOpenPostRequest($entry_id, $update_is_open_for_editing_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdOpenPost'
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\UpdateIsOpenForEditingRequest|null $update_is_open_for_editing_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdOpenPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdOpenPostRequest($entry_id, $update_is_open_for_editing_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdOpenPost'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdOpenPost'
            );
        }



        $resourcePath = '/v4/entries/{entryId}/open';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_is_open_for_editing_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_is_open_for_editing_request));
            } else {
                $httpBody = $update_is_open_for_editing_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdPatch
     *
     * Update a form entry
     *
     * @param  string $entry_id entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPatchRequest|null $v4_entries_entry_id_patch_request v4_entries_entry_id_patch_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4EntriesEntryIdPatch($entry_id, $v4_entries_entry_id_patch_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPatch'][0])
    {
        $this->v4EntriesEntryIdPatchWithHttpInfo($entry_id, $v4_entries_entry_id_patch_request, $contentType);
    }

    /**
     * Operation v4EntriesEntryIdPatchWithHttpInfo
     *
     * Update a form entry
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPatchRequest|null $v4_entries_entry_id_patch_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdPatchWithHttpInfo($entry_id, $v4_entries_entry_id_patch_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPatch'][0])
    {
        $request = $this->v4EntriesEntryIdPatchRequest($entry_id, $v4_entries_entry_id_patch_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdPatchAsync
     *
     * Update a form entry
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPatchRequest|null $v4_entries_entry_id_patch_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdPatchAsync($entry_id, $v4_entries_entry_id_patch_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPatch'][0])
    {
        return $this->v4EntriesEntryIdPatchAsyncWithHttpInfo($entry_id, $v4_entries_entry_id_patch_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdPatchAsyncWithHttpInfo
     *
     * Update a form entry
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPatchRequest|null $v4_entries_entry_id_patch_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdPatchAsyncWithHttpInfo($entry_id, $v4_entries_entry_id_patch_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPatch'][0])
    {
        $returnType = '';
        $request = $this->v4EntriesEntryIdPatchRequest($entry_id, $v4_entries_entry_id_patch_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdPatch'
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPatchRequest|null $v4_entries_entry_id_patch_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdPatchRequest($entry_id, $v4_entries_entry_id_patch_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPatch'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdPatch'
            );
        }



        $resourcePath = '/v4/entries/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($v4_entries_entry_id_patch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($v4_entries_entry_id_patch_request));
            } else {
                $httpBody = $v4_entries_entry_id_patch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdPut
     *
     * Update a form entry
     *
     * @param  string $entry_id entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPutRequest|null $v4_entries_entry_id_put_request v4_entries_entry_id_put_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response
     */
    public function v4EntriesEntryIdPut($entry_id, $v4_entries_entry_id_put_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPut'][0])
    {
        list($response) = $this->v4EntriesEntryIdPutWithHttpInfo($entry_id, $v4_entries_entry_id_put_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEntryIdPutWithHttpInfo
     *
     * Update a form entry
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPutRequest|null $v4_entries_entry_id_put_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdPutWithHttpInfo($entry_id, $v4_entries_entry_id_put_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPut'][0])
    {
        $request = $this->v4EntriesEntryIdPutRequest($entry_id, $v4_entries_entry_id_put_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdPutAsync
     *
     * Update a form entry
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPutRequest|null $v4_entries_entry_id_put_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdPutAsync($entry_id, $v4_entries_entry_id_put_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPut'][0])
    {
        return $this->v4EntriesEntryIdPutAsyncWithHttpInfo($entry_id, $v4_entries_entry_id_put_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdPutAsyncWithHttpInfo
     *
     * Update a form entry
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPutRequest|null $v4_entries_entry_id_put_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdPutAsyncWithHttpInfo($entry_id, $v4_entries_entry_id_put_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPut'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V4EntriesEntryIdGet200Response';
        $request = $this->v4EntriesEntryIdPutRequest($entry_id, $v4_entries_entry_id_put_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdPut'
     *
     * @param  string $entry_id (required)
     * @param  \OpenAPI\Client\Model\V4EntriesEntryIdPutRequest|null $v4_entries_entry_id_put_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdPutRequest($entry_id, $v4_entries_entry_id_put_request = null, string $contentType = self::contentTypes['v4EntriesEntryIdPut'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdPut'
            );
        }



        $resourcePath = '/v4/entries/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($v4_entries_entry_id_put_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($v4_entries_entry_id_put_request));
            } else {
                $httpBody = $v4_entries_entry_id_put_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesEntryIdTablesTableIdGet
     *
     * Get a url to download the table
     *
     * @param  string $entry_id entry_id (required)
     * @param  string $table_id table_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdTablesTableIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\GetUrlResponse|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4EntriesEntryIdTablesTableIdGet($entry_id, $table_id, string $contentType = self::contentTypes['v4EntriesEntryIdTablesTableIdGet'][0])
    {
        list($response) = $this->v4EntriesEntryIdTablesTableIdGetWithHttpInfo($entry_id, $table_id, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesEntryIdTablesTableIdGetWithHttpInfo
     *
     * Get a url to download the table
     *
     * @param  string $entry_id (required)
     * @param  string $table_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdTablesTableIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\GetUrlResponse|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesEntryIdTablesTableIdGetWithHttpInfo($entry_id, $table_id, string $contentType = self::contentTypes['v4EntriesEntryIdTablesTableIdGet'][0])
    {
        $request = $this->v4EntriesEntryIdTablesTableIdGetRequest($entry_id, $table_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\GetUrlResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\GetUrlResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\GetUrlResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\GetUrlResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\GetUrlResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesEntryIdTablesTableIdGetAsync
     *
     * Get a url to download the table
     *
     * @param  string $entry_id (required)
     * @param  string $table_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdTablesTableIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdTablesTableIdGetAsync($entry_id, $table_id, string $contentType = self::contentTypes['v4EntriesEntryIdTablesTableIdGet'][0])
    {
        return $this->v4EntriesEntryIdTablesTableIdGetAsyncWithHttpInfo($entry_id, $table_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesEntryIdTablesTableIdGetAsyncWithHttpInfo
     *
     * Get a url to download the table
     *
     * @param  string $entry_id (required)
     * @param  string $table_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdTablesTableIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesEntryIdTablesTableIdGetAsyncWithHttpInfo($entry_id, $table_id, string $contentType = self::contentTypes['v4EntriesEntryIdTablesTableIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\GetUrlResponse';
        $request = $this->v4EntriesEntryIdTablesTableIdGetRequest($entry_id, $table_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesEntryIdTablesTableIdGet'
     *
     * @param  string $entry_id (required)
     * @param  string $table_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesEntryIdTablesTableIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesEntryIdTablesTableIdGetRequest($entry_id, $table_id, string $contentType = self::contentTypes['v4EntriesEntryIdTablesTableIdGet'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesEntryIdTablesTableIdGet'
            );
        }

        // verify the required parameter 'table_id' is set
        if ($table_id === null || (is_array($table_id) && count($table_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $table_id when calling v4EntriesEntryIdTablesTableIdGet'
            );
        }


        $resourcePath = '/v4/entries/{entryId}/tables/{tableId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }
        // path params
        if ($table_id !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($table_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesFormsFormIdGet
     *
     * Get a page of completed form entries
     *
     * @param  string $form_id form_id (required)
     * @param  string|null $continuation_token continuation_token (optional)
     * @param  int|null $size size (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryResponse|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4EntriesFormsFormIdGet($form_id, $continuation_token = null, $size = 20, string $contentType = self::contentTypes['v4EntriesFormsFormIdGet'][0])
    {
        list($response) = $this->v4EntriesFormsFormIdGetWithHttpInfo($form_id, $continuation_token, $size, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesFormsFormIdGetWithHttpInfo
     *
     * Get a page of completed form entries
     *
     * @param  string $form_id (required)
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryResponse|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesFormsFormIdGetWithHttpInfo($form_id, $continuation_token = null, $size = 20, string $contentType = self::contentTypes['v4EntriesFormsFormIdGet'][0])
    {
        $request = $this->v4EntriesFormsFormIdGetRequest($form_id, $continuation_token, $size, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesFormsFormIdGetAsync
     *
     * Get a page of completed form entries
     *
     * @param  string $form_id (required)
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesFormsFormIdGetAsync($form_id, $continuation_token = null, $size = 20, string $contentType = self::contentTypes['v4EntriesFormsFormIdGet'][0])
    {
        return $this->v4EntriesFormsFormIdGetAsyncWithHttpInfo($form_id, $continuation_token, $size, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesFormsFormIdGetAsyncWithHttpInfo
     *
     * Get a page of completed form entries
     *
     * @param  string $form_id (required)
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesFormsFormIdGetAsyncWithHttpInfo($form_id, $continuation_token = null, $size = 20, string $contentType = self::contentTypes['v4EntriesFormsFormIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryResponse';
        $request = $this->v4EntriesFormsFormIdGetRequest($form_id, $continuation_token, $size, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesFormsFormIdGet'
     *
     * @param  string $form_id (required)
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesFormsFormIdGetRequest($form_id, $continuation_token = null, $size = 20, string $contentType = self::contentTypes['v4EntriesFormsFormIdGet'][0])
    {

        // verify the required parameter 'form_id' is set
        if ($form_id === null || (is_array($form_id) && count($form_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form_id when calling v4EntriesFormsFormIdGet'
            );
        }


        if ($size !== null && $size > 500) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling FormsApi.v4EntriesFormsFormIdGet, must be smaller than or equal to 500.');
        }
        if ($size !== null && $size < 1) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling FormsApi.v4EntriesFormsFormIdGet, must be bigger than or equal to 1.');
        }
        

        $resourcePath = '/v4/entries/forms/{formId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $continuation_token,
            'continuationToken', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($form_id !== null) {
            $resourcePath = str_replace(
                '{' . 'formId' . '}',
                ObjectSerializer::toPathValue($form_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesInternalPost
     *
     * Create an internal form entry
     *
     * @param  \OpenAPI\Client\Model\CreateInternalFormEntryRequest|null $create_internal_form_entry_request create_internal_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesInternalPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\InternalFormEntryResponse|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4EntriesInternalPost($create_internal_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesInternalPost'][0])
    {
        list($response) = $this->v4EntriesInternalPostWithHttpInfo($create_internal_form_entry_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesInternalPostWithHttpInfo
     *
     * Create an internal form entry
     *
     * @param  \OpenAPI\Client\Model\CreateInternalFormEntryRequest|null $create_internal_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesInternalPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\InternalFormEntryResponse|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesInternalPostWithHttpInfo($create_internal_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesInternalPost'][0])
    {
        $request = $this->v4EntriesInternalPostRequest($create_internal_form_entry_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\InternalFormEntryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\InternalFormEntryResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\InternalFormEntryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\InternalFormEntryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\InternalFormEntryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesInternalPostAsync
     *
     * Create an internal form entry
     *
     * @param  \OpenAPI\Client\Model\CreateInternalFormEntryRequest|null $create_internal_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesInternalPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesInternalPostAsync($create_internal_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesInternalPost'][0])
    {
        return $this->v4EntriesInternalPostAsyncWithHttpInfo($create_internal_form_entry_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesInternalPostAsyncWithHttpInfo
     *
     * Create an internal form entry
     *
     * @param  \OpenAPI\Client\Model\CreateInternalFormEntryRequest|null $create_internal_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesInternalPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesInternalPostAsyncWithHttpInfo($create_internal_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesInternalPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\InternalFormEntryResponse';
        $request = $this->v4EntriesInternalPostRequest($create_internal_form_entry_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesInternalPost'
     *
     * @param  \OpenAPI\Client\Model\CreateInternalFormEntryRequest|null $create_internal_form_entry_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesInternalPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesInternalPostRequest($create_internal_form_entry_request = null, string $contentType = self::contentTypes['v4EntriesInternalPost'][0])
    {



        $resourcePath = '/v4/entries/internal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_internal_form_entry_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_internal_form_entry_request));
            } else {
                $httpBody = $create_internal_form_entry_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesMessagePost
     *
     * Send message to entries
     *
     * @param  \OpenAPI\Client\Model\SendMessageToEntriesRequest|null $send_message_to_entries_request send_message_to_entries_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMessagePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4EntriesMessagePost($send_message_to_entries_request = null, string $contentType = self::contentTypes['v4EntriesMessagePost'][0])
    {
        $this->v4EntriesMessagePostWithHttpInfo($send_message_to_entries_request, $contentType);
    }

    /**
     * Operation v4EntriesMessagePostWithHttpInfo
     *
     * Send message to entries
     *
     * @param  \OpenAPI\Client\Model\SendMessageToEntriesRequest|null $send_message_to_entries_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMessagePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesMessagePostWithHttpInfo($send_message_to_entries_request = null, string $contentType = self::contentTypes['v4EntriesMessagePost'][0])
    {
        $request = $this->v4EntriesMessagePostRequest($send_message_to_entries_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesMessagePostAsync
     *
     * Send message to entries
     *
     * @param  \OpenAPI\Client\Model\SendMessageToEntriesRequest|null $send_message_to_entries_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMessagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesMessagePostAsync($send_message_to_entries_request = null, string $contentType = self::contentTypes['v4EntriesMessagePost'][0])
    {
        return $this->v4EntriesMessagePostAsyncWithHttpInfo($send_message_to_entries_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesMessagePostAsyncWithHttpInfo
     *
     * Send message to entries
     *
     * @param  \OpenAPI\Client\Model\SendMessageToEntriesRequest|null $send_message_to_entries_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMessagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesMessagePostAsyncWithHttpInfo($send_message_to_entries_request = null, string $contentType = self::contentTypes['v4EntriesMessagePost'][0])
    {
        $returnType = '';
        $request = $this->v4EntriesMessagePostRequest($send_message_to_entries_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesMessagePost'
     *
     * @param  \OpenAPI\Client\Model\SendMessageToEntriesRequest|null $send_message_to_entries_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMessagePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesMessagePostRequest($send_message_to_entries_request = null, string $contentType = self::contentTypes['v4EntriesMessagePost'][0])
    {



        $resourcePath = '/v4/entries/message';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($send_message_to_entries_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($send_message_to_entries_request));
            } else {
                $httpBody = $send_message_to_entries_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesMetadataFormsFormIdGet
     *
     * Get a page of form entry metadata
     *
     * @param  string $form_id form_id (required)
     * @param  string|null $continuation_token continuation_token (optional)
     * @param  int|null $size size (optional, default to 20)
     * @param  string[]|null $project_ids Additional and request form entries only (optional)
     * @param  string[]|null $states Additional and request form entries only (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortField|null $sort_by_sort &#39;dateSent&#39;, &#39;status&#39; and &#39;deadline&#39; only for Additional form entries. &#39;dateSubmitted&#39; and &#39;requestFormEntryStatus&#39; only for Request form entries (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortOrder|null $sort_by_direction sort_by_direction (optional)
     * @param  string[]|null $statuses Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_from Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_to Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_from Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_to Additional form entries only (optional)
     * @param  string[]|null $request_form_entry_statuses Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_from Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_to Request form entries only (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMetadataFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryMetadataResponse|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4EntriesMetadataFormsFormIdGet($form_id, $continuation_token = null, $size = 20, $project_ids = null, $states = null, $sort_by_sort = null, $sort_by_direction = null, $statuses = null, $sent_date_from = null, $sent_date_to = null, $deadline_date_from = null, $deadline_date_to = null, $request_form_entry_statuses = null, $submitted_date_from = null, $submitted_date_to = null, string $contentType = self::contentTypes['v4EntriesMetadataFormsFormIdGet'][0])
    {
        list($response) = $this->v4EntriesMetadataFormsFormIdGetWithHttpInfo($form_id, $continuation_token, $size, $project_ids, $states, $sort_by_sort, $sort_by_direction, $statuses, $sent_date_from, $sent_date_to, $deadline_date_from, $deadline_date_to, $request_form_entry_statuses, $submitted_date_from, $submitted_date_to, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesMetadataFormsFormIdGetWithHttpInfo
     *
     * Get a page of form entry metadata
     *
     * @param  string $form_id (required)
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string[]|null $project_ids Additional and request form entries only (optional)
     * @param  string[]|null $states Additional and request form entries only (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortField|null $sort_by_sort &#39;dateSent&#39;, &#39;status&#39; and &#39;deadline&#39; only for Additional form entries. &#39;dateSubmitted&#39; and &#39;requestFormEntryStatus&#39; only for Request form entries (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortOrder|null $sort_by_direction (optional)
     * @param  string[]|null $statuses Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_from Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_to Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_from Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_to Additional form entries only (optional)
     * @param  string[]|null $request_form_entry_statuses Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_from Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_to Request form entries only (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMetadataFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryMetadataResponse|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesMetadataFormsFormIdGetWithHttpInfo($form_id, $continuation_token = null, $size = 20, $project_ids = null, $states = null, $sort_by_sort = null, $sort_by_direction = null, $statuses = null, $sent_date_from = null, $sent_date_to = null, $deadline_date_from = null, $deadline_date_to = null, $request_form_entry_statuses = null, $submitted_date_from = null, $submitted_date_to = null, string $contentType = self::contentTypes['v4EntriesMetadataFormsFormIdGet'][0])
    {
        $request = $this->v4EntriesMetadataFormsFormIdGetRequest($form_id, $continuation_token, $size, $project_ids, $states, $sort_by_sort, $sort_by_direction, $statuses, $sent_date_from, $sent_date_to, $deadline_date_from, $deadline_date_to, $request_form_entry_statuses, $submitted_date_from, $submitted_date_to, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryMetadataResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryMetadataResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryMetadataResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryMetadataResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryMetadataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesMetadataFormsFormIdGetAsync
     *
     * Get a page of form entry metadata
     *
     * @param  string $form_id (required)
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string[]|null $project_ids Additional and request form entries only (optional)
     * @param  string[]|null $states Additional and request form entries only (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortField|null $sort_by_sort &#39;dateSent&#39;, &#39;status&#39; and &#39;deadline&#39; only for Additional form entries. &#39;dateSubmitted&#39; and &#39;requestFormEntryStatus&#39; only for Request form entries (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortOrder|null $sort_by_direction (optional)
     * @param  string[]|null $statuses Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_from Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_to Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_from Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_to Additional form entries only (optional)
     * @param  string[]|null $request_form_entry_statuses Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_from Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_to Request form entries only (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMetadataFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesMetadataFormsFormIdGetAsync($form_id, $continuation_token = null, $size = 20, $project_ids = null, $states = null, $sort_by_sort = null, $sort_by_direction = null, $statuses = null, $sent_date_from = null, $sent_date_to = null, $deadline_date_from = null, $deadline_date_to = null, $request_form_entry_statuses = null, $submitted_date_from = null, $submitted_date_to = null, string $contentType = self::contentTypes['v4EntriesMetadataFormsFormIdGet'][0])
    {
        return $this->v4EntriesMetadataFormsFormIdGetAsyncWithHttpInfo($form_id, $continuation_token, $size, $project_ids, $states, $sort_by_sort, $sort_by_direction, $statuses, $sent_date_from, $sent_date_to, $deadline_date_from, $deadline_date_to, $request_form_entry_statuses, $submitted_date_from, $submitted_date_to, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesMetadataFormsFormIdGetAsyncWithHttpInfo
     *
     * Get a page of form entry metadata
     *
     * @param  string $form_id (required)
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string[]|null $project_ids Additional and request form entries only (optional)
     * @param  string[]|null $states Additional and request form entries only (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortField|null $sort_by_sort &#39;dateSent&#39;, &#39;status&#39; and &#39;deadline&#39; only for Additional form entries. &#39;dateSubmitted&#39; and &#39;requestFormEntryStatus&#39; only for Request form entries (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortOrder|null $sort_by_direction (optional)
     * @param  string[]|null $statuses Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_from Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_to Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_from Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_to Additional form entries only (optional)
     * @param  string[]|null $request_form_entry_statuses Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_from Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_to Request form entries only (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMetadataFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesMetadataFormsFormIdGetAsyncWithHttpInfo($form_id, $continuation_token = null, $size = 20, $project_ids = null, $states = null, $sort_by_sort = null, $sort_by_direction = null, $statuses = null, $sent_date_from = null, $sent_date_to = null, $deadline_date_from = null, $deadline_date_to = null, $request_form_entry_statuses = null, $submitted_date_from = null, $submitted_date_to = null, string $contentType = self::contentTypes['v4EntriesMetadataFormsFormIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ContinuationTokenResponseAnyFormTypeEntryMetadataResponse';
        $request = $this->v4EntriesMetadataFormsFormIdGetRequest($form_id, $continuation_token, $size, $project_ids, $states, $sort_by_sort, $sort_by_direction, $statuses, $sent_date_from, $sent_date_to, $deadline_date_from, $deadline_date_to, $request_form_entry_statuses, $submitted_date_from, $submitted_date_to, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesMetadataFormsFormIdGet'
     *
     * @param  string $form_id (required)
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string[]|null $project_ids Additional and request form entries only (optional)
     * @param  string[]|null $states Additional and request form entries only (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortField|null $sort_by_sort &#39;dateSent&#39;, &#39;status&#39; and &#39;deadline&#39; only for Additional form entries. &#39;dateSubmitted&#39; and &#39;requestFormEntryStatus&#39; only for Request form entries (optional)
     * @param  \OpenAPI\Client\Model\FormEntrySortOrder|null $sort_by_direction (optional)
     * @param  string[]|null $statuses Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_from Additional form entries only (optional)
     * @param  \DateTime|null $sent_date_to Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_from Additional form entries only (optional)
     * @param  \DateTime|null $deadline_date_to Additional form entries only (optional)
     * @param  string[]|null $request_form_entry_statuses Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_from Request form entries only (optional)
     * @param  \DateTime|null $submitted_date_to Request form entries only (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesMetadataFormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesMetadataFormsFormIdGetRequest($form_id, $continuation_token = null, $size = 20, $project_ids = null, $states = null, $sort_by_sort = null, $sort_by_direction = null, $statuses = null, $sent_date_from = null, $sent_date_to = null, $deadline_date_from = null, $deadline_date_to = null, $request_form_entry_statuses = null, $submitted_date_from = null, $submitted_date_to = null, string $contentType = self::contentTypes['v4EntriesMetadataFormsFormIdGet'][0])
    {

        // verify the required parameter 'form_id' is set
        if ($form_id === null || (is_array($form_id) && count($form_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form_id when calling v4EntriesMetadataFormsFormIdGet'
            );
        }


        if ($size !== null && $size > 500) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling FormsApi.v4EntriesMetadataFormsFormIdGet, must be smaller than or equal to 500.');
        }
        if ($size !== null && $size < 1) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling FormsApi.v4EntriesMetadataFormsFormIdGet, must be bigger than or equal to 1.');
        }
        













        $resourcePath = '/v4/entries/metadata/forms/{formId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $continuation_token,
            'continuationToken', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $project_ids,
            'ProjectIds', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $states,
            'States', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by_sort,
            'SortBy.sort', // param base name
            'FormEntrySortField', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sort_by_direction,
            'SortBy.direction', // param base name
            'FormEntrySortOrder', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $statuses,
            'Statuses', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sent_date_from,
            'SentDateFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sent_date_to,
            'SentDateTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deadline_date_from,
            'DeadlineDateFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deadline_date_to,
            'DeadlineDateTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $request_form_entry_statuses,
            'RequestFormEntryStatuses', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $submitted_date_from,
            'SubmittedDateFrom', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $submitted_date_to,
            'SubmittedDateTo', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($form_id !== null) {
            $resourcePath = str_replace(
                '{' . 'formId' . '}',
                ObjectSerializer::toPathValue($form_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesRequestFilterEditingClosePut
     *
     * Close request form entries for editing by filter
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingClosePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4EntriesRequestFilterEditingClosePut($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingClosePut'][0])
    {
        $this->v4EntriesRequestFilterEditingClosePutWithHttpInfo($update_request_form_is_open_for_editing_by_filter_request, $contentType);
    }

    /**
     * Operation v4EntriesRequestFilterEditingClosePutWithHttpInfo
     *
     * Close request form entries for editing by filter
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingClosePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesRequestFilterEditingClosePutWithHttpInfo($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingClosePut'][0])
    {
        $request = $this->v4EntriesRequestFilterEditingClosePutRequest($update_request_form_is_open_for_editing_by_filter_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesRequestFilterEditingClosePutAsync
     *
     * Close request form entries for editing by filter
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingClosePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesRequestFilterEditingClosePutAsync($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingClosePut'][0])
    {
        return $this->v4EntriesRequestFilterEditingClosePutAsyncWithHttpInfo($update_request_form_is_open_for_editing_by_filter_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesRequestFilterEditingClosePutAsyncWithHttpInfo
     *
     * Close request form entries for editing by filter
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingClosePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesRequestFilterEditingClosePutAsyncWithHttpInfo($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingClosePut'][0])
    {
        $returnType = '';
        $request = $this->v4EntriesRequestFilterEditingClosePutRequest($update_request_form_is_open_for_editing_by_filter_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesRequestFilterEditingClosePut'
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingClosePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesRequestFilterEditingClosePutRequest($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingClosePut'][0])
    {



        $resourcePath = '/v4/entries/request/filter/editing/close';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_request_form_is_open_for_editing_by_filter_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_request_form_is_open_for_editing_by_filter_request));
            } else {
                $httpBody = $update_request_form_is_open_for_editing_by_filter_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesRequestFilterEditingOpenPut
     *
     * Open request form entries for editing by filter
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingOpenPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4EntriesRequestFilterEditingOpenPut($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingOpenPut'][0])
    {
        $this->v4EntriesRequestFilterEditingOpenPutWithHttpInfo($update_request_form_is_open_for_editing_by_filter_request, $contentType);
    }

    /**
     * Operation v4EntriesRequestFilterEditingOpenPutWithHttpInfo
     *
     * Open request form entries for editing by filter
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingOpenPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesRequestFilterEditingOpenPutWithHttpInfo($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingOpenPut'][0])
    {
        $request = $this->v4EntriesRequestFilterEditingOpenPutRequest($update_request_form_is_open_for_editing_by_filter_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesRequestFilterEditingOpenPutAsync
     *
     * Open request form entries for editing by filter
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingOpenPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesRequestFilterEditingOpenPutAsync($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingOpenPut'][0])
    {
        return $this->v4EntriesRequestFilterEditingOpenPutAsyncWithHttpInfo($update_request_form_is_open_for_editing_by_filter_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesRequestFilterEditingOpenPutAsyncWithHttpInfo
     *
     * Open request form entries for editing by filter
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingOpenPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesRequestFilterEditingOpenPutAsyncWithHttpInfo($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingOpenPut'][0])
    {
        $returnType = '';
        $request = $this->v4EntriesRequestFilterEditingOpenPutRequest($update_request_form_is_open_for_editing_by_filter_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesRequestFilterEditingOpenPut'
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormIsOpenForEditingByFilterRequest|null $update_request_form_is_open_for_editing_by_filter_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestFilterEditingOpenPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesRequestFilterEditingOpenPutRequest($update_request_form_is_open_for_editing_by_filter_request = null, string $contentType = self::contentTypes['v4EntriesRequestFilterEditingOpenPut'][0])
    {



        $resourcePath = '/v4/entries/request/filter/editing/open';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_request_form_is_open_for_editing_by_filter_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_request_form_is_open_for_editing_by_filter_request));
            } else {
                $httpBody = $update_request_form_is_open_for_editing_by_filter_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesRequestStatusPut
     *
     * Update status on request form entries
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormEntryStatusRequest|null $update_request_form_entry_status_request update_request_form_entry_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestStatusPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|string[]
     */
    public function v4EntriesRequestStatusPut($update_request_form_entry_status_request = null, string $contentType = self::contentTypes['v4EntriesRequestStatusPut'][0])
    {
        list($response) = $this->v4EntriesRequestStatusPutWithHttpInfo($update_request_form_entry_status_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesRequestStatusPutWithHttpInfo
     *
     * Update status on request form entries
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormEntryStatusRequest|null $update_request_form_entry_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestStatusPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|string[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesRequestStatusPutWithHttpInfo($update_request_form_entry_status_request = null, string $contentType = self::contentTypes['v4EntriesRequestStatusPut'][0])
    {
        $request = $this->v4EntriesRequestStatusPutRequest($update_request_form_entry_status_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('string[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesRequestStatusPutAsync
     *
     * Update status on request form entries
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormEntryStatusRequest|null $update_request_form_entry_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestStatusPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesRequestStatusPutAsync($update_request_form_entry_status_request = null, string $contentType = self::contentTypes['v4EntriesRequestStatusPut'][0])
    {
        return $this->v4EntriesRequestStatusPutAsyncWithHttpInfo($update_request_form_entry_status_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesRequestStatusPutAsyncWithHttpInfo
     *
     * Update status on request form entries
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormEntryStatusRequest|null $update_request_form_entry_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestStatusPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesRequestStatusPutAsyncWithHttpInfo($update_request_form_entry_status_request = null, string $contentType = self::contentTypes['v4EntriesRequestStatusPut'][0])
    {
        $returnType = 'string[]';
        $request = $this->v4EntriesRequestStatusPutRequest($update_request_form_entry_status_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesRequestStatusPut'
     *
     * @param  \OpenAPI\Client\Model\UpdateRequestFormEntryStatusRequest|null $update_request_form_entry_status_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesRequestStatusPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesRequestStatusPutRequest($update_request_form_entry_status_request = null, string $contentType = self::contentTypes['v4EntriesRequestStatusPut'][0])
    {



        $resourcePath = '/v4/entries/request/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_request_form_entry_status_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_request_form_entry_status_request));
            } else {
                $httpBody = $update_request_form_entry_status_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesReviewsEntryIdDelete
     *
     * Delete a review entry by id
     *
     * @param  string $entry_id entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4EntriesReviewsEntryIdDelete($entry_id, string $contentType = self::contentTypes['v4EntriesReviewsEntryIdDelete'][0])
    {
        $this->v4EntriesReviewsEntryIdDeleteWithHttpInfo($entry_id, $contentType);
    }

    /**
     * Operation v4EntriesReviewsEntryIdDeleteWithHttpInfo
     *
     * Delete a review entry by id
     *
     * @param  string $entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesReviewsEntryIdDeleteWithHttpInfo($entry_id, string $contentType = self::contentTypes['v4EntriesReviewsEntryIdDelete'][0])
    {
        $request = $this->v4EntriesReviewsEntryIdDeleteRequest($entry_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesReviewsEntryIdDeleteAsync
     *
     * Delete a review entry by id
     *
     * @param  string $entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesReviewsEntryIdDeleteAsync($entry_id, string $contentType = self::contentTypes['v4EntriesReviewsEntryIdDelete'][0])
    {
        return $this->v4EntriesReviewsEntryIdDeleteAsyncWithHttpInfo($entry_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesReviewsEntryIdDeleteAsyncWithHttpInfo
     *
     * Delete a review entry by id
     *
     * @param  string $entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesReviewsEntryIdDeleteAsyncWithHttpInfo($entry_id, string $contentType = self::contentTypes['v4EntriesReviewsEntryIdDelete'][0])
    {
        $returnType = '';
        $request = $this->v4EntriesReviewsEntryIdDeleteRequest($entry_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesReviewsEntryIdDelete'
     *
     * @param  string $entry_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsEntryIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesReviewsEntryIdDeleteRequest($entry_id, string $contentType = self::contentTypes['v4EntriesReviewsEntryIdDelete'][0])
    {

        // verify the required parameter 'entry_id' is set
        if ($entry_id === null || (is_array($entry_id) && count($entry_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $entry_id when calling v4EntriesReviewsEntryIdDelete'
            );
        }


        $resourcePath = '/v4/entries/reviews/{entryId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($entry_id !== null) {
            $resourcePath = str_replace(
                '{' . 'entryId' . '}',
                ObjectSerializer::toPathValue($entry_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesReviewsScorePut
     *
     * Update a review score
     *
     * @param  \OpenAPI\Client\Model\UpdateReviewScoreRequest|null $update_review_score_request update_review_score_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsScorePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\ReviewFormEntryResponse
     */
    public function v4EntriesReviewsScorePut($update_review_score_request = null, string $contentType = self::contentTypes['v4EntriesReviewsScorePut'][0])
    {
        list($response) = $this->v4EntriesReviewsScorePutWithHttpInfo($update_review_score_request, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesReviewsScorePutWithHttpInfo
     *
     * Update a review score
     *
     * @param  \OpenAPI\Client\Model\UpdateReviewScoreRequest|null $update_review_score_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsScorePut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\ReviewFormEntryResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesReviewsScorePutWithHttpInfo($update_review_score_request = null, string $contentType = self::contentTypes['v4EntriesReviewsScorePut'][0])
    {
        $request = $this->v4EntriesReviewsScorePutRequest($update_review_score_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 201:
                    if ('\OpenAPI\Client\Model\ReviewFormEntryResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ReviewFormEntryResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ReviewFormEntryResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ReviewFormEntryResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ReviewFormEntryResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesReviewsScorePutAsync
     *
     * Update a review score
     *
     * @param  \OpenAPI\Client\Model\UpdateReviewScoreRequest|null $update_review_score_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsScorePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesReviewsScorePutAsync($update_review_score_request = null, string $contentType = self::contentTypes['v4EntriesReviewsScorePut'][0])
    {
        return $this->v4EntriesReviewsScorePutAsyncWithHttpInfo($update_review_score_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesReviewsScorePutAsyncWithHttpInfo
     *
     * Update a review score
     *
     * @param  \OpenAPI\Client\Model\UpdateReviewScoreRequest|null $update_review_score_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsScorePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesReviewsScorePutAsyncWithHttpInfo($update_review_score_request = null, string $contentType = self::contentTypes['v4EntriesReviewsScorePut'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ReviewFormEntryResponse';
        $request = $this->v4EntriesReviewsScorePutRequest($update_review_score_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesReviewsScorePut'
     *
     * @param  \OpenAPI\Client\Model\UpdateReviewScoreRequest|null $update_review_score_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesReviewsScorePut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesReviewsScorePutRequest($update_review_score_request = null, string $contentType = self::contentTypes['v4EntriesReviewsScorePut'][0])
    {



        $resourcePath = '/v4/entries/reviews/score';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_review_score_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_review_score_request));
            } else {
                $httpBody = $update_review_score_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesSubmissionsSubmissionIdGet
     *
     * Get a submission&#39;s entries
     *
     * @param  string $submission_id submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FormEntriesForSubmissionResponse|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4EntriesSubmissionsSubmissionIdGet($submission_id, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'][0])
    {
        list($response) = $this->v4EntriesSubmissionsSubmissionIdGetWithHttpInfo($submission_id, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesSubmissionsSubmissionIdGetWithHttpInfo
     *
     * Get a submission&#39;s entries
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FormEntriesForSubmissionResponse|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesSubmissionsSubmissionIdGetWithHttpInfo($submission_id, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'][0])
    {
        $request = $this->v4EntriesSubmissionsSubmissionIdGetRequest($submission_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FormEntriesForSubmissionResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FormEntriesForSubmissionResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FormEntriesForSubmissionResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\FormEntriesForSubmissionResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FormEntriesForSubmissionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesSubmissionsSubmissionIdGetAsync
     *
     * Get a submission&#39;s entries
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesSubmissionsSubmissionIdGetAsync($submission_id, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'][0])
    {
        return $this->v4EntriesSubmissionsSubmissionIdGetAsyncWithHttpInfo($submission_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesSubmissionsSubmissionIdGetAsyncWithHttpInfo
     *
     * Get a submission&#39;s entries
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesSubmissionsSubmissionIdGetAsyncWithHttpInfo($submission_id, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FormEntriesForSubmissionResponse';
        $request = $this->v4EntriesSubmissionsSubmissionIdGetRequest($submission_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesSubmissionsSubmissionIdGet'
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesSubmissionsSubmissionIdGetRequest($submission_id, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdGet'][0])
    {

        // verify the required parameter 'submission_id' is set
        if ($submission_id === null || (is_array($submission_id) && count($submission_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submission_id when calling v4EntriesSubmissionsSubmissionIdGet'
            );
        }


        $resourcePath = '/v4/entries/submissions/{submissionId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($submission_id !== null) {
            $resourcePath = str_replace(
                '{' . 'submissionId' . '}',
                ObjectSerializer::toPathValue($submission_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4EntriesSubmissionsSubmissionIdReviewsGet
     *
     * Get reviews for a Submission
     *
     * @param  string $submission_id submission_id (required)
     * @param  string|null $review_stage_id review_stage_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ReviewFormEntryResponse[]
     */
    public function v4EntriesSubmissionsSubmissionIdReviewsGet($submission_id, $review_stage_id = null, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'][0])
    {
        list($response) = $this->v4EntriesSubmissionsSubmissionIdReviewsGetWithHttpInfo($submission_id, $review_stage_id, $contentType);
        return $response;
    }

    /**
     * Operation v4EntriesSubmissionsSubmissionIdReviewsGetWithHttpInfo
     *
     * Get reviews for a Submission
     *
     * @param  string $submission_id (required)
     * @param  string|null $review_stage_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ReviewFormEntryResponse[], HTTP status code, HTTP response headers (array of strings)
     */
    public function v4EntriesSubmissionsSubmissionIdReviewsGetWithHttpInfo($submission_id, $review_stage_id = null, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'][0])
    {
        $request = $this->v4EntriesSubmissionsSubmissionIdReviewsGetRequest($submission_id, $review_stage_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ReviewFormEntryResponse[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ReviewFormEntryResponse[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ReviewFormEntryResponse[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ReviewFormEntryResponse[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ReviewFormEntryResponse[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4EntriesSubmissionsSubmissionIdReviewsGetAsync
     *
     * Get reviews for a Submission
     *
     * @param  string $submission_id (required)
     * @param  string|null $review_stage_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesSubmissionsSubmissionIdReviewsGetAsync($submission_id, $review_stage_id = null, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'][0])
    {
        return $this->v4EntriesSubmissionsSubmissionIdReviewsGetAsyncWithHttpInfo($submission_id, $review_stage_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4EntriesSubmissionsSubmissionIdReviewsGetAsyncWithHttpInfo
     *
     * Get reviews for a Submission
     *
     * @param  string $submission_id (required)
     * @param  string|null $review_stage_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4EntriesSubmissionsSubmissionIdReviewsGetAsyncWithHttpInfo($submission_id, $review_stage_id = null, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ReviewFormEntryResponse[]';
        $request = $this->v4EntriesSubmissionsSubmissionIdReviewsGetRequest($submission_id, $review_stage_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4EntriesSubmissionsSubmissionIdReviewsGet'
     *
     * @param  string $submission_id (required)
     * @param  string|null $review_stage_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4EntriesSubmissionsSubmissionIdReviewsGetRequest($submission_id, $review_stage_id = null, string $contentType = self::contentTypes['v4EntriesSubmissionsSubmissionIdReviewsGet'][0])
    {

        // verify the required parameter 'submission_id' is set
        if ($submission_id === null || (is_array($submission_id) && count($submission_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submission_id when calling v4EntriesSubmissionsSubmissionIdReviewsGet'
            );
        }



        $resourcePath = '/v4/entries/submissions/{submissionId}/reviews';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $review_stage_id,
            'reviewStageId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($submission_id !== null) {
            $resourcePath = str_replace(
                '{' . 'submissionId' . '}',
                ObjectSerializer::toPathValue($submission_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsFormIdDelete
     *
     * Delete a form
     *
     * @param  string $form_id  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4FormsFormIdDelete($form_id, string $contentType = self::contentTypes['v4FormsFormIdDelete'][0])
    {
        $this->v4FormsFormIdDeleteWithHttpInfo($form_id, $contentType);
    }

    /**
     * Operation v4FormsFormIdDeleteWithHttpInfo
     *
     * Delete a form
     *
     * @param  string $form_id  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsFormIdDeleteWithHttpInfo($form_id, string $contentType = self::contentTypes['v4FormsFormIdDelete'][0])
    {
        $request = $this->v4FormsFormIdDeleteRequest($form_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsFormIdDeleteAsync
     *
     * Delete a form
     *
     * @param  string $form_id  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsFormIdDeleteAsync($form_id, string $contentType = self::contentTypes['v4FormsFormIdDelete'][0])
    {
        return $this->v4FormsFormIdDeleteAsyncWithHttpInfo($form_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsFormIdDeleteAsyncWithHttpInfo
     *
     * Delete a form
     *
     * @param  string $form_id  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsFormIdDeleteAsyncWithHttpInfo($form_id, string $contentType = self::contentTypes['v4FormsFormIdDelete'][0])
    {
        $returnType = '';
        $request = $this->v4FormsFormIdDeleteRequest($form_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsFormIdDelete'
     *
     * @param  string $form_id  (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsFormIdDeleteRequest($form_id, string $contentType = self::contentTypes['v4FormsFormIdDelete'][0])
    {

        // verify the required parameter 'form_id' is set
        if ($form_id === null || (is_array($form_id) && count($form_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form_id when calling v4FormsFormIdDelete'
            );
        }


        $resourcePath = '/v4/forms/{formId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($form_id !== null) {
            $resourcePath = str_replace(
                '{' . 'formId' . '}',
                ObjectSerializer::toPathValue($form_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsFormIdGet
     *
     * Get a form
     *
     * @param  string $form_id form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\V4FormsPost201Response
     */
    public function v4FormsFormIdGet($form_id, string $contentType = self::contentTypes['v4FormsFormIdGet'][0])
    {
        list($response) = $this->v4FormsFormIdGetWithHttpInfo($form_id, $contentType);
        return $response;
    }

    /**
     * Operation v4FormsFormIdGetWithHttpInfo
     *
     * Get a form
     *
     * @param  string $form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\V4FormsPost201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsFormIdGetWithHttpInfo($form_id, string $contentType = self::contentTypes['v4FormsFormIdGet'][0])
    {
        $request = $this->v4FormsFormIdGetRequest($form_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('\OpenAPI\Client\Model\V4FormsPost201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V4FormsPost201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V4FormsPost201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\V4FormsPost201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V4FormsPost201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsFormIdGetAsync
     *
     * Get a form
     *
     * @param  string $form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsFormIdGetAsync($form_id, string $contentType = self::contentTypes['v4FormsFormIdGet'][0])
    {
        return $this->v4FormsFormIdGetAsyncWithHttpInfo($form_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsFormIdGetAsyncWithHttpInfo
     *
     * Get a form
     *
     * @param  string $form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsFormIdGetAsyncWithHttpInfo($form_id, string $contentType = self::contentTypes['v4FormsFormIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V4FormsPost201Response';
        $request = $this->v4FormsFormIdGetRequest($form_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsFormIdGet'
     *
     * @param  string $form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsFormIdGetRequest($form_id, string $contentType = self::contentTypes['v4FormsFormIdGet'][0])
    {

        // verify the required parameter 'form_id' is set
        if ($form_id === null || (is_array($form_id) && count($form_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form_id when calling v4FormsFormIdGet'
            );
        }


        $resourcePath = '/v4/forms/{formId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($form_id !== null) {
            $resourcePath = str_replace(
                '{' . 'formId' . '}',
                ObjectSerializer::toPathValue($form_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsFormIdPut
     *
     * Update a form
     *
     * @param  string $form_id form_id (required)
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\V4FormsPost201Response
     */
    public function v4FormsFormIdPut($form_id, $v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsFormIdPut'][0])
    {
        list($response) = $this->v4FormsFormIdPutWithHttpInfo($form_id, $v4_forms_post_request, $contentType);
        return $response;
    }

    /**
     * Operation v4FormsFormIdPutWithHttpInfo
     *
     * Update a form
     *
     * @param  string $form_id (required)
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdPut'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\V4FormsPost201Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsFormIdPutWithHttpInfo($form_id, $v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsFormIdPut'][0])
    {
        $request = $this->v4FormsFormIdPutRequest($form_id, $v4_forms_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 201:
                    if ('\OpenAPI\Client\Model\V4FormsPost201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V4FormsPost201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V4FormsPost201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\V4FormsPost201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V4FormsPost201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsFormIdPutAsync
     *
     * Update a form
     *
     * @param  string $form_id (required)
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsFormIdPutAsync($form_id, $v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsFormIdPut'][0])
    {
        return $this->v4FormsFormIdPutAsyncWithHttpInfo($form_id, $v4_forms_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsFormIdPutAsyncWithHttpInfo
     *
     * Update a form
     *
     * @param  string $form_id (required)
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsFormIdPutAsyncWithHttpInfo($form_id, $v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsFormIdPut'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V4FormsPost201Response';
        $request = $this->v4FormsFormIdPutRequest($form_id, $v4_forms_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsFormIdPut'
     *
     * @param  string $form_id (required)
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsFormIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsFormIdPutRequest($form_id, $v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsFormIdPut'][0])
    {

        // verify the required parameter 'form_id' is set
        if ($form_id === null || (is_array($form_id) && count($form_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $form_id when calling v4FormsFormIdPut'
            );
        }



        $resourcePath = '/v4/forms/{formId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($form_id !== null) {
            $resourcePath = str_replace(
                '{' . 'formId' . '}',
                ObjectSerializer::toPathValue($form_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($v4_forms_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($v4_forms_post_request));
            } else {
                $httpBody = $v4_forms_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsGet
     *
     * Get a page of forms
     *
     * @param  string|null $continuation_token continuation_token (optional)
     * @param  int|null $size size (optional, default to 20)
     * @param  string|null $type type (optional)
     * @param  string|null $project_id project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\ContinuationTokenResponseFormResponseV4
     */
    public function v4FormsGet($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsGet'][0])
    {
        list($response) = $this->v4FormsGetWithHttpInfo($continuation_token, $size, $type, $project_id, $contentType);
        return $response;
    }

    /**
     * Operation v4FormsGetWithHttpInfo
     *
     * Get a page of forms
     *
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string|null $type (optional)
     * @param  string|null $project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\ContinuationTokenResponseFormResponseV4, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsGetWithHttpInfo($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsGet'][0])
    {
        $request = $this->v4FormsGetRequest($continuation_token, $size, $type, $project_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('\OpenAPI\Client\Model\ContinuationTokenResponseFormResponseV4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ContinuationTokenResponseFormResponseV4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContinuationTokenResponseFormResponseV4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ContinuationTokenResponseFormResponseV4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContinuationTokenResponseFormResponseV4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsGetAsync
     *
     * Get a page of forms
     *
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string|null $type (optional)
     * @param  string|null $project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsGetAsync($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsGet'][0])
    {
        return $this->v4FormsGetAsyncWithHttpInfo($continuation_token, $size, $type, $project_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsGetAsyncWithHttpInfo
     *
     * Get a page of forms
     *
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string|null $type (optional)
     * @param  string|null $project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsGetAsyncWithHttpInfo($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ContinuationTokenResponseFormResponseV4';
        $request = $this->v4FormsGetRequest($continuation_token, $size, $type, $project_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsGet'
     *
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string|null $type (optional)
     * @param  string|null $project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsGetRequest($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsGet'][0])
    {


        if ($size !== null && $size > 500) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling FormsApi.v4FormsGet, must be smaller than or equal to 500.');
        }
        if ($size !== null && $size < 1) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling FormsApi.v4FormsGet, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/v4/forms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $continuation_token,
            'continuationToken', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $project_id,
            'projectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsMetadataGet
     *
     * Get a page of form metadata
     *
     * @param  string|null $continuation_token continuation_token (optional)
     * @param  int|null $size size (optional, default to 20)
     * @param  string|null $type type (optional)
     * @param  string|null $project_id project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\ContinuationTokenResponseFormMetadataResponse
     */
    public function v4FormsMetadataGet($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsMetadataGet'][0])
    {
        list($response) = $this->v4FormsMetadataGetWithHttpInfo($continuation_token, $size, $type, $project_id, $contentType);
        return $response;
    }

    /**
     * Operation v4FormsMetadataGetWithHttpInfo
     *
     * Get a page of form metadata
     *
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string|null $type (optional)
     * @param  string|null $project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsMetadataGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BadRequestResponse|\OpenAPI\Client\Model\ContinuationTokenResponseFormMetadataResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsMetadataGetWithHttpInfo($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsMetadataGet'][0])
    {
        $request = $this->v4FormsMetadataGetRequest($continuation_token, $size, $type, $project_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 200:
                    if ('\OpenAPI\Client\Model\ContinuationTokenResponseFormMetadataResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ContinuationTokenResponseFormMetadataResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ContinuationTokenResponseFormMetadataResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ContinuationTokenResponseFormMetadataResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ContinuationTokenResponseFormMetadataResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsMetadataGetAsync
     *
     * Get a page of form metadata
     *
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string|null $type (optional)
     * @param  string|null $project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsMetadataGetAsync($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsMetadataGet'][0])
    {
        return $this->v4FormsMetadataGetAsyncWithHttpInfo($continuation_token, $size, $type, $project_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsMetadataGetAsyncWithHttpInfo
     *
     * Get a page of form metadata
     *
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string|null $type (optional)
     * @param  string|null $project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsMetadataGetAsyncWithHttpInfo($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsMetadataGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ContinuationTokenResponseFormMetadataResponse';
        $request = $this->v4FormsMetadataGetRequest($continuation_token, $size, $type, $project_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsMetadataGet'
     *
     * @param  string|null $continuation_token (optional)
     * @param  int|null $size (optional, default to 20)
     * @param  string|null $type (optional)
     * @param  string|null $project_id (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsMetadataGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsMetadataGetRequest($continuation_token = null, $size = 20, $type = null, $project_id = null, string $contentType = self::contentTypes['v4FormsMetadataGet'][0])
    {


        if ($size !== null && $size > 500) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling FormsApi.v4FormsMetadataGet, must be smaller than or equal to 500.');
        }
        if ($size !== null && $size < 1) {
            throw new \InvalidArgumentException('invalid value for "$size" when calling FormsApi.v4FormsMetadataGet, must be bigger than or equal to 1.');
        }
        



        $resourcePath = '/v4/forms/metadata';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $continuation_token,
            'continuationToken', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $size,
            'size', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $project_id,
            'projectId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsPost
     *
     * Create a form
     *
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\V4FormsPost201Response|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4FormsPost($v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsPost'][0])
    {
        list($response) = $this->v4FormsPostWithHttpInfo($v4_forms_post_request, $contentType);
        return $response;
    }

    /**
     * Operation v4FormsPostWithHttpInfo
     *
     * Create a form
     *
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\V4FormsPost201Response|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsPostWithHttpInfo($v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsPost'][0])
    {
        $request = $this->v4FormsPostRequest($v4_forms_post_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\V4FormsPost201Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\V4FormsPost201Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\V4FormsPost201Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\V4FormsPost201Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\V4FormsPost201Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsPostAsync
     *
     * Create a form
     *
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsPostAsync($v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsPost'][0])
    {
        return $this->v4FormsPostAsyncWithHttpInfo($v4_forms_post_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsPostAsyncWithHttpInfo
     *
     * Create a form
     *
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsPostAsyncWithHttpInfo($v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\V4FormsPost201Response';
        $request = $this->v4FormsPostRequest($v4_forms_post_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsPost'
     *
     * @param  \OpenAPI\Client\Model\V4FormsPostRequest|null $v4_forms_post_request (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsPostRequest($v4_forms_post_request = null, string $contentType = self::contentTypes['v4FormsPost'][0])
    {



        $resourcePath = '/v4/forms';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($v4_forms_post_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($v4_forms_post_request));
            } else {
                $httpBody = $v4_forms_post_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsScheduledScheduledAdditionalFormIdDelete
     *
     * Delete scheduled additional form by id
     *
     * @param  string $scheduled_additional_form_id scheduled_additional_form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4FormsScheduledScheduledAdditionalFormIdDelete($scheduled_additional_form_id, string $contentType = self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'][0])
    {
        $this->v4FormsScheduledScheduledAdditionalFormIdDeleteWithHttpInfo($scheduled_additional_form_id, $contentType);
    }

    /**
     * Operation v4FormsScheduledScheduledAdditionalFormIdDeleteWithHttpInfo
     *
     * Delete scheduled additional form by id
     *
     * @param  string $scheduled_additional_form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsScheduledScheduledAdditionalFormIdDeleteWithHttpInfo($scheduled_additional_form_id, string $contentType = self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'][0])
    {
        $request = $this->v4FormsScheduledScheduledAdditionalFormIdDeleteRequest($scheduled_additional_form_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsScheduledScheduledAdditionalFormIdDeleteAsync
     *
     * Delete scheduled additional form by id
     *
     * @param  string $scheduled_additional_form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsScheduledScheduledAdditionalFormIdDeleteAsync($scheduled_additional_form_id, string $contentType = self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'][0])
    {
        return $this->v4FormsScheduledScheduledAdditionalFormIdDeleteAsyncWithHttpInfo($scheduled_additional_form_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsScheduledScheduledAdditionalFormIdDeleteAsyncWithHttpInfo
     *
     * Delete scheduled additional form by id
     *
     * @param  string $scheduled_additional_form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsScheduledScheduledAdditionalFormIdDeleteAsyncWithHttpInfo($scheduled_additional_form_id, string $contentType = self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'][0])
    {
        $returnType = '';
        $request = $this->v4FormsScheduledScheduledAdditionalFormIdDeleteRequest($scheduled_additional_form_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsScheduledScheduledAdditionalFormIdDelete'
     *
     * @param  string $scheduled_additional_form_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsScheduledScheduledAdditionalFormIdDeleteRequest($scheduled_additional_form_id, string $contentType = self::contentTypes['v4FormsScheduledScheduledAdditionalFormIdDelete'][0])
    {

        // verify the required parameter 'scheduled_additional_form_id' is set
        if ($scheduled_additional_form_id === null || (is_array($scheduled_additional_form_id) && count($scheduled_additional_form_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $scheduled_additional_form_id when calling v4FormsScheduledScheduledAdditionalFormIdDelete'
            );
        }


        $resourcePath = '/v4/forms/scheduled/{scheduledAdditionalFormId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($scheduled_additional_form_id !== null) {
            $resourcePath = str_replace(
                '{' . 'scheduledAdditionalFormId' . '}',
                ObjectSerializer::toPathValue($scheduled_additional_form_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsSubmissionIdScheduledGet
     *
     * Get scheduled additional forms by submission
     *
     * @param  string $submission_id submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsSubmissionIdScheduledGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ScheduledAdditionalFormsBySubmissionIdResponse
     */
    public function v4FormsSubmissionIdScheduledGet($submission_id, string $contentType = self::contentTypes['v4FormsSubmissionIdScheduledGet'][0])
    {
        list($response) = $this->v4FormsSubmissionIdScheduledGetWithHttpInfo($submission_id, $contentType);
        return $response;
    }

    /**
     * Operation v4FormsSubmissionIdScheduledGetWithHttpInfo
     *
     * Get scheduled additional forms by submission
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsSubmissionIdScheduledGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ScheduledAdditionalFormsBySubmissionIdResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsSubmissionIdScheduledGetWithHttpInfo($submission_id, string $contentType = self::contentTypes['v4FormsSubmissionIdScheduledGet'][0])
    {
        $request = $this->v4FormsSubmissionIdScheduledGetRequest($submission_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ScheduledAdditionalFormsBySubmissionIdResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ScheduledAdditionalFormsBySubmissionIdResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ScheduledAdditionalFormsBySubmissionIdResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\ScheduledAdditionalFormsBySubmissionIdResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ScheduledAdditionalFormsBySubmissionIdResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsSubmissionIdScheduledGetAsync
     *
     * Get scheduled additional forms by submission
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsSubmissionIdScheduledGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsSubmissionIdScheduledGetAsync($submission_id, string $contentType = self::contentTypes['v4FormsSubmissionIdScheduledGet'][0])
    {
        return $this->v4FormsSubmissionIdScheduledGetAsyncWithHttpInfo($submission_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsSubmissionIdScheduledGetAsyncWithHttpInfo
     *
     * Get scheduled additional forms by submission
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsSubmissionIdScheduledGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsSubmissionIdScheduledGetAsyncWithHttpInfo($submission_id, string $contentType = self::contentTypes['v4FormsSubmissionIdScheduledGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ScheduledAdditionalFormsBySubmissionIdResponse';
        $request = $this->v4FormsSubmissionIdScheduledGetRequest($submission_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsSubmissionIdScheduledGet'
     *
     * @param  string $submission_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsSubmissionIdScheduledGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsSubmissionIdScheduledGetRequest($submission_id, string $contentType = self::contentTypes['v4FormsSubmissionIdScheduledGet'][0])
    {

        // verify the required parameter 'submission_id' is set
        if ($submission_id === null || (is_array($submission_id) && count($submission_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $submission_id when calling v4FormsSubmissionIdScheduledGet'
            );
        }


        $resourcePath = '/v4/forms/{submissionId}/scheduled';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($submission_id !== null) {
            $resourcePath = str_replace(
                '{' . 'submissionId' . '}',
                ObjectSerializer::toPathValue($submission_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4FormsTemplatesPaymentGet
     *
     * Clone payment template
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsTemplatesPaymentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\FormTemplateResponse|\OpenAPI\Client\Model\BadRequestResponse
     */
    public function v4FormsTemplatesPaymentGet(string $contentType = self::contentTypes['v4FormsTemplatesPaymentGet'][0])
    {
        list($response) = $this->v4FormsTemplatesPaymentGetWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation v4FormsTemplatesPaymentGetWithHttpInfo
     *
     * Clone payment template
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsTemplatesPaymentGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\FormTemplateResponse|\OpenAPI\Client\Model\BadRequestResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4FormsTemplatesPaymentGetWithHttpInfo(string $contentType = self::contentTypes['v4FormsTemplatesPaymentGet'][0])
    {
        $request = $this->v4FormsTemplatesPaymentGetRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\FormTemplateResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\FormTemplateResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\FormTemplateResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\BadRequestResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\BadRequestResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\BadRequestResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\OpenAPI\Client\Model\FormTemplateResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\FormTemplateResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4FormsTemplatesPaymentGetAsync
     *
     * Clone payment template
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsTemplatesPaymentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsTemplatesPaymentGetAsync(string $contentType = self::contentTypes['v4FormsTemplatesPaymentGet'][0])
    {
        return $this->v4FormsTemplatesPaymentGetAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4FormsTemplatesPaymentGetAsyncWithHttpInfo
     *
     * Clone payment template
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsTemplatesPaymentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4FormsTemplatesPaymentGetAsyncWithHttpInfo(string $contentType = self::contentTypes['v4FormsTemplatesPaymentGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\FormTemplateResponse';
        $request = $this->v4FormsTemplatesPaymentGetRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4FormsTemplatesPaymentGet'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4FormsTemplatesPaymentGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4FormsTemplatesPaymentGetRequest(string $contentType = self::contentTypes['v4FormsTemplatesPaymentGet'][0])
    {


        $resourcePath = '/v4/forms/templates/payment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation v4ReviewsReviewResponseIdDelete
     *
     * Delete a review by id
     *
     * @param  string $review_response_id review_response_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4ReviewsReviewResponseIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function v4ReviewsReviewResponseIdDelete($review_response_id, string $contentType = self::contentTypes['v4ReviewsReviewResponseIdDelete'][0])
    {
        $this->v4ReviewsReviewResponseIdDeleteWithHttpInfo($review_response_id, $contentType);
    }

    /**
     * Operation v4ReviewsReviewResponseIdDeleteWithHttpInfo
     *
     * Delete a review by id
     *
     * @param  string $review_response_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4ReviewsReviewResponseIdDelete'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function v4ReviewsReviewResponseIdDeleteWithHttpInfo($review_response_id, string $contentType = self::contentTypes['v4ReviewsReviewResponseIdDelete'][0])
    {
        $request = $this->v4ReviewsReviewResponseIdDeleteRequest($review_response_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BadRequestResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation v4ReviewsReviewResponseIdDeleteAsync
     *
     * Delete a review by id
     *
     * @param  string $review_response_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4ReviewsReviewResponseIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4ReviewsReviewResponseIdDeleteAsync($review_response_id, string $contentType = self::contentTypes['v4ReviewsReviewResponseIdDelete'][0])
    {
        return $this->v4ReviewsReviewResponseIdDeleteAsyncWithHttpInfo($review_response_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation v4ReviewsReviewResponseIdDeleteAsyncWithHttpInfo
     *
     * Delete a review by id
     *
     * @param  string $review_response_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4ReviewsReviewResponseIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function v4ReviewsReviewResponseIdDeleteAsyncWithHttpInfo($review_response_id, string $contentType = self::contentTypes['v4ReviewsReviewResponseIdDelete'][0])
    {
        $returnType = '';
        $request = $this->v4ReviewsReviewResponseIdDeleteRequest($review_response_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'v4ReviewsReviewResponseIdDelete'
     *
     * @param  string $review_response_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['v4ReviewsReviewResponseIdDelete'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function v4ReviewsReviewResponseIdDeleteRequest($review_response_id, string $contentType = self::contentTypes['v4ReviewsReviewResponseIdDelete'][0])
    {

        // verify the required parameter 'review_response_id' is set
        if ($review_response_id === null || (is_array($review_response_id) && count($review_response_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $review_response_id when calling v4ReviewsReviewResponseIdDelete'
            );
        }


        $resourcePath = '/v4/reviews/{reviewResponseId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($review_response_id !== null) {
            $resourcePath = str_replace(
                '{' . 'reviewResponseId' . '}',
                ObjectSerializer::toPathValue($review_response_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
